--- a/tools/firmware-utils/src/tplink-safeloader.c
+++ b/tools/firmware-utils/src/tplink-safeloader.c
@@ -103,7 +103,7 @@ static const uint8_t md5_salt[16] = {
 
 
 /** Vendor information for CPE210/220/510/520 */
-static const unsigned char cpe510_vendor[] = "\x00\x00\x00\x1f""CPE510(TP-LINK|UN|N300-5):1.0\r\n";
+static const char cpe510_vendor[] = "CPE510(TP-LINK|UN|N300-5):1.0\r\n";
 
 
 /**
@@ -129,18 +129,17 @@ static const struct flash_partition_entr
 
 /**
    The support list for CPE210/220/510/520
-
-   The stock images also contain strings for two more devices: BS510 and BS210.
-   At the moment, there exists no public information about these devices.
 */
-static const unsigned char cpe510_support_list[] =
-	"\x00\x00\x00\xc8\x00\x00\x00\x00"
+static const char cpe510_support_list[] =
 	"SupportList:\r\n"
 	"CPE510(TP-LINK|UN|N300-5):1.0\r\n"
+	"CPE510(TP-LINK|UN|N300-5):1.1\r\n"
 	"CPE520(TP-LINK|UN|N300-5):1.0\r\n"
+	"CPE520(TP-LINK|UN|N300-5):1.1\r\n"
 	"CPE210(TP-LINK|UN|N300-2):1.0\r\n"
+	"CPE210(TP-LINK|UN|N300-2):1.1\r\n"
 	"CPE220(TP-LINK|UN|N300-2):1.0\r\n"
-	"\r\n\xff";
+	"CPE220(TP-LINK|UN|N300-2):1.1\r\n";
 
 #define error(_ret, _errno, _str, ...)				\
 	do {							\
@@ -151,8 +150,16 @@ static const unsigned char cpe510_suppor
 	} while (0)
 
 
+/** Stores a uint32 as big endian */
+static inline void put32(uint8_t *buf, uint32_t val) {
+	buf[0] = val >> 24;
+	buf[1] = val >> 16;
+	buf[2] = val >> 8;
+	buf[3] = val;
+}
+
 /** Allocates a new image partition */
-struct image_partition_entry alloc_image_partition(const char *name, size_t len) {
+static struct image_partition_entry alloc_image_partition(const char *name, size_t len) {
 	struct image_partition_entry entry = {name, len, malloc(len)};
 	if (!entry.data)
 		error(1, errno, "malloc");
@@ -161,12 +168,12 @@ struct image_partition_entry alloc_image
 }
 
 /** Frees an image partition */
-void free_image_partition(struct image_partition_entry entry) {
+static void free_image_partition(struct image_partition_entry entry) {
 	free(entry.data);
 }
 
 /** Generates the partition-table partition */
-struct image_partition_entry make_partition_table(const struct flash_partition_entry *p) {
+static struct image_partition_entry make_partition_table(const struct flash_partition_entry *p) {
 	struct image_partition_entry entry = alloc_image_partition("partition-table", 0x800);
 
 	char *s = (char *)entry.data, *end = (char *)(s+entry.size);
@@ -202,7 +209,7 @@ static inline uint8_t bcd(uint8_t v) {
 
 
 /** Generates the soft-version partition */
-struct image_partition_entry make_soft_version(uint32_t rev) {
+static struct image_partition_entry make_soft_version(uint32_t rev) {
 	struct image_partition_entry entry = alloc_image_partition("soft-version", sizeof(struct soft_version));
 	struct soft_version *s = (struct soft_version *)entry.data;
 
@@ -233,14 +240,20 @@ struct image_partition_entry make_soft_v
 }
 
 /** Generates the support-list partition */
-struct image_partition_entry make_support_list(const unsigned char *support_list, size_t len) {
-	struct image_partition_entry entry = alloc_image_partition("support-list", len);
-	memcpy(entry.data, support_list, len);
+static struct image_partition_entry make_support_list(const char *support_list) {
+	size_t len = strlen(support_list);
+	struct image_partition_entry entry = alloc_image_partition("support-list", len + 9);
+
+	put32(entry.data, len);
+	memset(entry.data+4, 0, 4);
+	memcpy(entry.data+8, support_list, len);
+	entry.data[len+8] = '\xff';
+
 	return entry;
 }
 
 /** Creates a new image partition with an arbitrary name from a file */
-struct image_partition_entry read_file(const char *part_name, const char *filename, bool add_jffs2_eof) {
+static struct image_partition_entry read_file(const char *part_name, const char *filename, bool add_jffs2_eof) {
 	struct stat statbuf;
 
 	if (stat(filename, &statbuf) < 0)
@@ -300,7 +313,7 @@ struct image_partition_entry read_file(c
 
    I think partition-table must be the first partition in the firmware image.
 */
-void put_partitions(uint8_t *buffer, const struct image_partition_entry *parts) {
+static void put_partitions(uint8_t *buffer, const struct image_partition_entry *parts) {
 	size_t i;
 	char *image_pt = (char *)buffer, *end = image_pt + 0x800;
 
@@ -325,7 +338,7 @@ void put_partitions(uint8_t *buffer, con
 }
 
 /** Generates and writes the image MD5 checksum */
-void put_md5(uint8_t *md5, uint8_t *buffer, unsigned int len) {
+static void put_md5(uint8_t *md5, uint8_t *buffer, unsigned int len) {
 	MD5_CTX ctx;
 
 	MD5_Init(&ctx);
@@ -344,12 +357,13 @@ void put_md5(uint8_t *md5, uint8_t *buff
      -----------  -----
      0000-0003    Image size (4 bytes, big endian)
      0004-0013    MD5 hash (hash of a 16 byte salt and the image data starting with byte 0x14)
-     0014-1013    Vendor information (4096 bytes, padded with 0xff; there seem to be older
+     0014-0017    Vendor information length (without padding) (4 bytes, big endian)
+     0018-1013    Vendor information (4092 bytes, padded with 0xff; there seem to be older
                   (VxWorks-based) TP-LINK devices which use a smaller vendor information block)
      1014-1813    Image partition table (2048 bytes, padded with 0xff)
      1814-xxxx    Firmware partitions
 */
-void * generate_factory_image(const unsigned char *vendor, size_t vendor_len, const struct image_partition_entry *parts, size_t *len) {
+static void * generate_factory_image(const char *vendor, const struct image_partition_entry *parts, size_t *len) {
 	*len = 0x1814;
 
 	size_t i;
@@ -360,13 +374,12 @@ void * generate_factory_image(const unsi
 	if (!image)
 		error(1, errno, "malloc");
 
-	image[0] = *len >> 24;
-	image[1] = *len >> 16;
-	image[2] = *len >> 8;
-	image[3] = *len;
+	put32(image, *len);
 
-	memcpy(image+0x14, vendor, vendor_len);
-	memset(image+0x14+vendor_len, 0xff, 4096-vendor_len);
+	size_t vendor_len = strlen(vendor);
+	put32(image+0x14, vendor_len);
+	memcpy(image+0x18, vendor, vendor_len);
+	memset(image+0x18+vendor_len, 0xff, 4092-vendor_len);
 
 	put_partitions(image + 0x1014, parts);
 	put_md5(image+0x04, image+0x14, *len-0x14);
@@ -381,7 +394,7 @@ void * generate_factory_image(const unsi
    should be generalized when TP-LINK starts building its safeloader into hardware with
    different flash layouts.
 */
-void * generate_sysupgrade_image(const struct flash_partition_entry *flash_parts, const struct image_partition_entry *image_parts, size_t *len) {
+static void * generate_sysupgrade_image(const struct flash_partition_entry *flash_parts, const struct image_partition_entry *image_parts, size_t *len) {
 	const struct flash_partition_entry *flash_os_image = &flash_parts[5];
 	const struct flash_partition_entry *flash_soft_version = &flash_parts[6];
 	const struct flash_partition_entry *flash_support_list = &flash_parts[7];
@@ -430,7 +443,7 @@ static void do_cpe510(const char *output
 
 	parts[0] = make_partition_table(cpe510_partitions);
 	parts[1] = make_soft_version(rev);
-	parts[2] = make_support_list(cpe510_support_list, sizeof(cpe510_support_list)-1);
+	parts[2] = make_support_list(cpe510_support_list);
 	parts[3] = read_file("os-image", kernel_image, false);
 	parts[4] = read_file("file-system", rootfs_image, add_jffs2_eof);
 
@@ -439,7 +452,7 @@ static void do_cpe510(const char *output
 	if (sysupgrade)
 		image = generate_sysupgrade_image(cpe510_partitions, parts, &len);
 	else
-		image = generate_factory_image(cpe510_vendor, sizeof(cpe510_vendor)-1, parts, &len);
+		image = generate_factory_image(cpe510_vendor, parts, &len);
 
 	FILE *file = fopen(output, "wb");
 	if (!file)
@@ -459,7 +472,7 @@ static void do_cpe510(const char *output
 
 
 /** Usage output */
-void usage(const char *argv0) {
+static void usage(const char *argv0) {
 	fprintf(stderr,
 		"Usage: %s [OPTIONS...]\n"
 		"\n"
